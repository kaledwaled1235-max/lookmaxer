<!doctype html>
<html lang="ar">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Face Classifier — Front+Side (Local)</title>
<style>
  :root{--bg:#050506;--card:#0e0f11;--muted:#9aa0a6;--accent:#fff;--blue:#2e8cff}
  html,body{height:100%;margin:0;font-family:system-ui,Arial;direction:rtl;background:linear-gradient(180deg,#020203,#0b0b0c);color:var(--accent);display:flex;align-items:center;justify-content:center;padding:12px}
  .phone{width:390px;height:820px;border-radius:20px;background:linear-gradient(180deg,var(--card),#070708);padding:14px;box-shadow:0 30px 60px rgba(0,0,0,0.6);display:flex;flex-direction:column;gap:12px}
  header{display:flex;justify-content:space-between;align-items:center}
  h1{margin:0;font-size:18px}
  .btn{padding:8px 12px;border-radius:10px;border:0;background:#111;color:var(--accent);cursor:pointer;font-size:13px}
  .btn.primary{background:var(--accent);color:#000}
  .camera{background:#060607;border-radius:12px;padding:8px;display:flex;flex-direction:column;gap:8px;align-items:center}
  video{width:100%;height:360px;border-radius:10px;background:#000;object-fit:cover}
  .thumbs{display:flex;gap:8px;justify-content:center}
  .thumb{width:120px;height:160px;border-radius:8px;background:#050506;object-fit:cover}
  .steps{display:flex;gap:6px;justify-content:center}
  .step{padding:6px 8px;border-radius:8px;background:#0a0a0b;color:var(--muted);font-size:12px}
  .step.active{background:linear-gradient(180deg,var(--blue),#0048c9);color:#fff}
  .metrics{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px}
  .card{background:#070708;padding:10px;border-radius:10px}
  .label{font-size:12px;color:var(--muted)}
  .value{font-weight:700;font-size:16px;margin-top:6px}
  .small{font-size:12px;color:var(--muted);margin-top:6px}
  footer{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:12px}
</style>

<!-- Mediapipe -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
  <div class="phone" id="app">
    <header>
      <div><h1 id="title">Face Classifier</h1><div id="subtitle" class="small">Capture front + side → local classification</div></div>
      <div><button class="btn" id="startBtn">Start</button></div>
    </header>

    <div class="camera card">
      <div style="width:100%;display:flex;justify-content:space-between;align-items:center">
        <div class="steps">
          <div class="step active" id="step1">1 Front</div>
          <div class="step" id="step2">2 Side</div>
          <div class="step" id="step3">3 Result</div>
        </div>
        <div style="display:flex;gap:8px">
          <button class="btn" id="capBtn">Capture</button>
          <button class="btn" id="analyzeBtn">Analyze</button>
        </div>
      </div>

      <video id="video" autoplay playsinline></video>
      <canvas id="canvas" width="720" height="1280" style="display:none"></canvas>

      <div class="thumbs"><img id="frontThumb" class="thumb"/><img id="sideThumb" class="thumb"/></div>
      <div class="small">التقط صورة أمامية ثم لف وشك جنب وصوّر — الإضاءة مهمة</div>
    </div>

    <div class="card">
      <div class="label">تصنيف (Tier)</div>
      <div class="value" id="tierVal">--</div>

      <div style="margin-top:10px" class="label">PSL Scale & Fields</div>
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-top:8px">
        <div>
          <div class="label">PSL Score</div><div class="value" id="psl">--</div>
        </div>
        <div>
          <div class="label">Mindset</div><div class="value" id="mindset">--</div>
        </div>
        <div>
          <div class="label">Strategy</div><div class="value" id="strategy">--</div>
        </div>
        <div>
          <div class="label">Jawline Type</div><div class="value" id="jawtype">--</div>
        </div>
        <div>
          <div class="label">Breathing</div><div class="value" id="breath">--</div>
        </div>
        <div>
          <div class="label">Appeal Level</div><div class="value" id="appeal">--</div>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="label">Raw metrics (محايد)</div>
      <div style="display:flex;gap:8px;margin-top:8px;flex-wrap:wrap">
        <div style="min-width:120px"><div class="small">Symmetry</div><div class="value" id="symVal">--</div></div>
        <div style="min-width:120px"><div class="small">Jaw angle</div><div class="value" id="jawVal">--</div></div>
        <div style="min-width:120px"><div class="small">Chin proj</div><div class="value" id="chinVal">--</div></div>
        <div style="min-width:120px"><div class="small">Nose ratio</div><div class="value" id="noseVal">--</div></div>
        <div style="min-width:120px"><div class="small">Eye ratio</div><div class="value" id="eyeVal">--</div></div>
        <div style="min-width:120px"><div class="small">Skin score</div><div class="value" id="skinVal">--</div></div>
      </div>
    </div>

    <footer><div id="note" class="small">التحليل محلي على جهازك — النتائج حسابية بحتة</div><div><button class="btn" id="resetBtn">Reset</button></div></footer>
  </div>

<script>
/*
  Usage:
  - Start -> Allow camera
  - Capture front: position face front then click Capture
  - Turn head ~90deg for side then Capture again
  - Click Analyze -> script runs mediapipe on both images, computes metrics, maps to tier + PSL fields
  All runs on-device.
*/

const faceMesh = new window.FaceMesh({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`});
faceMesh.setOptions({maxNumFaces:1,minDetectionConfidence:0.6,minTrackingConfidence:0.6});

// helpers
const clamp01 = v => Math.max(0,Math.min(1,v));
const toPct = v => Math.round(clamp01(v)*100);

// state
let stage = 1;
let frontDataUrl = null, sideDataUrl = null;
const video = document.getElementById('video');
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

document.getElementById('startBtn').addEventListener('click', async ()=>{
  try{
    const s = await navigator.mediaDevices.getUserMedia({video:{width:720,height:1280},audio:false});
    video.srcObject = s; await video.play();
  }catch(e){ alert('Camera error'); }
});

document.getElementById('capBtn').addEventListener('click', ()=>{
  if(!video.srcObject){ alert('Start camera first'); return; }
  canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  ctx.drawImage(video,0,0,canvas.width,canvas.height);
  const dataUrl = canvas.toDataURL('image/jpeg',0.9);
  if(stage===1){
    frontDataUrl = dataUrl; document.getElementById('frontThumb').src = dataUrl;
    stage = 2; setStep(2); alert('Now turn your head ~90° and press Capture again');
  } else if(stage===2){
    sideDataUrl = dataUrl; document.getElementById('sideThumb').src = dataUrl;
    stage = 3; setStep(3); alert('Captured both. Press Analyze.');
  }
});

function setStep(n){
  document.getElementById('step1').classList.toggle('active', n===1);
  document.getElementById('step2').classList.toggle('active', n===2);
  document.getElementById('step3').classList.toggle('active', n===3);
}

async function runFaceMeshOnDataUrl(dataUrl){
  return new Promise((res)=>{
    const img = new Image();
    img.onload = async ()=>{
      const tmp = document.createElement('canvas'); tmp.width = img.naturalWidth; tmp.height = img.naturalHeight;
      const tctx = tmp.getContext('2d'); tctx.drawImage(img,0,0,tmp.width,tmp.height);
      const imageData = tctx.getImageData(0,0,tmp.width,tmp.height);
      faceMesh.onResults((results)=>{ 
        // clone landmarks to plain arrays
        if(results && results.multiFaceLandmarks && results.multiFaceLandmarks.length>0){
          res({landmarks: results.multiFaceLandmarks[0], imageData});
        } else res(null);
      });
      await faceMesh.send({image: tmp}).catch(()=>res(null));
    };
    img.src = dataUrl;
  });
}

// metric calculators (heuristic)
function computeMetrics(landmarks, imageData){
  if(!landmarks) return null;
  let cx=0, cy=0;
  for(const p of landmarks){ cx += p.x; cy += p.y; }
  cx /= landmarks.length; cy /= landmarks.length;

  // symmetry pairs
  const pairs = [[33,263],[133,362],[61,291],[199,429]];
  let symSum=0, cnt=0;
  for(const pr of pairs){
    const a = landmarks[pr[0]], b = landmarks[pr[1]];
    if(a && b){
      const da = Math.hypot(a.x-cx, a.y-cy);
      const db = Math.hypot(b.x-cx, b.y-cy);
      symSum += 1 - Math.abs(da-db)/Math.max(da,db,1e-6);
      cnt++;
    }
  }
  const symmetry = cnt? symSum/cnt : 0.5;

  // jaw angle (angle at chin using two jaw points)
  const li = landmarks[234], chin = landmarks[152], ri = landmarks[454];
  let jawAngleScore = 0.5;
  if(li && chin && ri){
    const v1 = {x:li.x-chin.x, y:li.y-chin.y};
    const v2 = {x:ri.x-chin.x, y:ri.y-chin.y};
    const dot = v1.x*v2.x + v1.y*v2.y;
    const mag = Math.hypot(v1.x,v1.y)*Math.hypot(v2.x,v2.y) + 1e-6;
    const cosv = clamp01(dot/mag);
    const ang = Math.acos(cosv); // rad
    // smaller angle -> sharper jaw. Map ang (0.5..2.0) -> score
    jawAngleScore = 1 - ((ang - 0.6)/(1.6-0.6)); 
    jawAngleScore = clamp01(jawAngleScore);
  }

  // chin projection (x distance from centroid)
  let chinProj = 0.5;
  if(chin) chinProj = clamp01(1 - Math.abs(chin.x - cx) * 2);

  // nose ratio (height / face reference)
  const noseTop = landmarks[1], mouthTop = landmarks[13], forehead = landmarks[10];
  let noseRatio = 0.6;
  if(noseTop && mouthTop){
    const len = Math.abs(noseTop.y - mouthTop.y);
    const ref = forehead ? Math.abs(forehead.y - mouthTop.y) : 0.5;
    const ratio = len / (ref || 0.5);
    noseRatio = clamp01(1 - Math.abs(ratio - 0.18) * 4);
  }

  // eye ratio (distance between eyes / face width)
  let eyeRatio = 0.6;
  const le = landmarks[33], re = landmarks[263];
  if(le && re){
    const eyeDist = Math.hypot(le.x - re.x, le.y - re.y);
    const cheekL = landmarks[234], cheekR = landmarks[454];
    if(cheekL && cheekR){
      const faceW = Math.hypot(cheekL.x - cheekR.x, cheekL.y - cheekR.y);
      const ratio = eyeDist / faceW;
      eyeRatio = clamp01(1 - Math.abs(ratio - 0.27) * 3);
    }
  }

  // skin smoothness estimate from imageData around nose
  let skinScore = 0.7;
  try{
    if(imageData && noseTop){
      const w = imageData.width, h = imageData.height;
      const nx = Math.round(noseTop.x * w), ny = Math.round(noseTop.y * h);
      const box = Math.max(8, Math.round(Math.min(w,h)*0.02));
      let mean=0, cnt=0;
      for(let yy = Math.max(0,ny-box); yy < Math.min(h,ny+box); yy++){
        for(let xx = Math.max(0,nx-box); xx < Math.min(w,nx+box); xx++){
          const idx = (yy*w + xx)*4;
          const r = imageData.data[idx], g = imageData.data[idx+1], b = imageData.data[idx+2];
          const lum = 0.299*r + 0.587*g + 0.114*b;
          mean += lum; cnt++;
        }
      }
      mean /= Math.max(1,cnt);
      let varsum = 0;
      for(let yy = Math.max(0,ny-box); yy < Math.min(h,ny+box); yy++){
        for(let xx = Math.max(0,nx-box); xx < Math.min(w,nx+box); xx++){
          const idx = (yy*w + xx)*4;
          const r = imageData.data[idx], g = imageData.data[idx+1], b = imageData.data[idx+2];
          const lum = 0.299*r + 0.587*g + 0.114*b;
          varsum += (lum - mean)*(lum - mean);
        }
      }
      const variance = varsum / Math.max(1,cnt);
      skinScore = clamp01(1 - Math.min(3000, variance)/3000);
    }
  }catch(e){ /* ignore */ }

  return {
    symmetry, jawAngleScore, chinProj, noseRatio, eyeRatio, skinScore
  };
}

// aggregate to final score (0..1)
function aggregate(m){
  const w = {symmetry:0.25, jawAngleScore:0.25, chinProj:0.12, noseRatio:0.12, eyeRatio:0.16, skinScore:0.1};
  let tot=0, sum=0;
  for(const k in w){ tot += (m[k]||0) * w[k]; sum += w[k]; }
  return tot / sum;
}

// map final numeric to tiers
function mapTier(score){
  if(score < 0.30) return 'Sub 5';
  if(score < 0.45) return 'LTN';
  if(score < 0.60) return 'MTN';
  if(score < 0.75) return 'HTN';
  if(score < 0.90) return 'ADAM';
  return 'TRUE ADAM';
}

// Map metrics to PSL fields heuristically
function mapPSLFields(m, finalScore){
  // PSL Score: Low / Mid / High based on finalScore
  const psl = finalScore < 0.4 ? 'Low' : finalScore < 0.65 ? 'Medium' : 'High';

  // Mindset: from symmetry+jaw - arbitrary labels
  const msv = (m.symmetry + m.jawAngleScore)/2;
  const mindset = msv > 0.7 ? 'Confident' : msv > 0.5 ? 'Balanced' : 'Reserved';

  // Strategy: based on skin & jaw
  const strat = (m.skinScore > 0.6 && m.jawAngleScore > 0.55) ? 'Grooming+Fitness' : (m.skinScore > 0.6 ? 'Skincare' : 'Posture+Angles');

  // Jawline Type: soft/defined/sharp
  const jt = m.jawAngleScore < 0.45 ? 'Soft' : m.jawAngleScore < 0.65 ? 'Defined' : 'Sharp';

  // Breathing: rough proxy from noseRatio (not accurate medical)
  const breath = m.noseRatio > 0.6 ? 'Nasal Normal' : 'Mouth Tendency';

  // Appeal Level: Low/Medium/High using finalScore
  const appeal = finalScore < 0.4 ? 'Low' : finalScore < 0.7 ? 'Medium' : 'High';

  return {psl, mindset, strat, jt, breath, appeal};
}

// analyze both images
document.getElementById('analyzeBtn').addEventListener('click', async ()=>{
  if(!frontDataUrl || !sideDataUrl){ alert('محتاج صورتين: front و side'); return; }
  document.getElementById('subtitle').innerText = 'Analyzing...';
  const outF = await runFaceMeshOnDataUrl(frontDataUrl);
  const outS = await runFaceMeshOnDataUrl(sideDataUrl);
  if(!outF || !outS){ alert('ما قدرناش نلاقي وجه في صورة/ات — جرب إضاءة أفضل أو زاوية أو بعد أقل'); document.getElementById('subtitle').innerText='Capture front + side'; return; }

  const mF = computeMetrics(outF.landmarks, outF.imageData);
  const mS = computeMetrics(outS.landmarks, outS.imageData);
  // average
  const combined = {};
  for(const k of ['symmetry','jawAngleScore','chinProj','noseRatio','eyeRatio','skinScore']){
    combined[k] = ((mF[k] || 0) + (mS[k] || 0)) / 2;
  }

  // update raw metric UI
  document.getElementById('symVal').innerText = toPct(combined.symmetry) + '%';
  document.getElementById('jawVal').innerText = toPct(combined.jawAngleScore) + '%';
  document.getElementById('chinVal').innerText = toPct(combined.chinProj) + '%';
  document.getElementById('noseVal').innerText = toPct(combined.noseRatio) + '%';
  document.getElementById('eyeVal').innerText = toPct(combined.eyeRatio) + '%';
  document.getElementById('skinVal').innerText = toPct(combined.skinScore) + '%';

  const final = aggregate(combined);
  const tier = mapTier(final);
  document.getElementById('tierVal').innerText = tier;

  // PSL fields
  const fields = mapPSLFields(combined, final);
  document.getElementById('psl').innerText = fields.psl;
  document.getElementById('mindset').innerText = fields.mindset;
  document.getElementById('strategy').innerText = fields.strat;
  document.getElementById('jawtype').innerText = fields.jt;
  document.getElementById('breath').innerText = fields.breath;
  document.getElementById('appeal').innerText = fields.appeal;

  // show numeric final as percent scale for convenience
  document.getElementById('psl').innerText += ` (${Math.round(final*100)}%)`;

  document.getElementById('subtitle').innerText = 'Done — results local to your device';
  saveHistory(final, tier);
});

// helpers for running mediapipe on dataUrl (image)
function runFaceMeshOnDataUrl(dataUrl){
  return new Promise((res)=>{
    const img = new Image();
    img.onload = async ()=>{
      const tmp = document.createElement('canvas'); tmp.width = img.naturalWidth; tmp.height = img.naturalHeight;
      const tctx = tmp.getContext('2d'); tctx.drawImage(img,0,0,tmp.width,tmp.height);
      const imgData = tctx.getImageData(0,0,tmp.width,tmp.height);
      faceMesh.onResults((results) => {
        if(results && results.multiFaceLandmarks && results.multiFaceLandmarks.length>0){
          res({landmarks: results.multiFaceLandmarks[0], imageData: imgData});
        } else res(null);
      });
      await faceMesh.send({image: tmp}).catch(()=>res(null));
    };
    img.src = dataUrl;
  });
}

// capture flow logic
document.getElementById('startBtn').addEventListener('click', async ()=>{
  try{
    const s = await navigator.mediaDevices.getUserMedia({video:{width:720,height:1280},audio:false});
    video.srcObject = s; await video.play();
    alert('Camera started — position face frontal and press Capture');
  }catch(e){ alert('Camera error'); }
});

document.getElementById('capBtn').addEventListener('click', ()=>{
  if(!video.srcObject){ alert('Start camera first'); return; }
  canvas.width = video.videoWidth; canvas.height = video.videoHeight;
  ctx.drawImage(video,0,0,canvas.width,canvas.height);
  const dataUrl = canvas.toDataURL('image/jpeg',0.9);
  if(stage===1){ frontDataUrl = dataUrl; document.getElementById('frontThumb').src = dataUrl; stage = 2; setStep(2); alert('Turn head ~90° and press Capture again for side'); }
  else if(stage===2){ sideDataUrl = dataUrl; document.getElementById('sideThumb').src = dataUrl; stage = 3; setStep(3); alert('Both captured — press Analyze'); }
});

document.getElementById('resetBtn').addEventListener('click', ()=>{
  frontDataUrl = sideDataUrl = null; stage = 1; setStep(1);
  document.getElementById('frontThumb').src = ''; document.getElementById('sideThumb').src = '';
  ['tierVal','psl','mindset','strategy','jawtype','breath','appeal','symVal','jawVal','chinVal','noseVal','eyeVal','skinVal'].forEach(id=>document.getElementById(id).innerText='--');
  document.getElementById('subtitle').innerText = 'Capture front + side → local classification';
});

// save history locally
function saveHistory(final, tier){
  const hist = JSON.parse(localStorage.getItem('fc_history')||'[]');
  hist.unshift({date:new Date().toLocaleString(),score:Math.round(final*100)/100,tier});
  localStorage.setItem('fc_history', JSON.stringify(hist.slice(0,12)));
}

</script>
</body>
</html>
